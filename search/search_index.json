{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"authors/","title":"About me","text":""},{"location":"2024/01/19/chip-war-by-chris-miller/","title":"Chip War by Chris Miller","text":"<p>CHIP WAR - The fight for the world's most critical technology by Chris Miller is a fascinating read. It is deservingly the FT Business Book of the Year 2022.</p> <p>The book traces development of semiconductor chips from their infancy to the current state. But, it's not just a technology history book. It is a captivating triangulation of technology, business and politics surrounding semiconductor chips. The three parallel streams go all the way from cover to cover, and it's the superb inter-mixing of these that give the book it's edge.</p> <p>The author walks us through technical milestones in the evolution of semiconductor technology, starting from an interconnected mess of wires, eventually leading to nanometer scale structures constituting modern chips. The book brings out the differences between various kind of chips like processors, DRAMs, GPUs and NAND flash. It covers both design and manufacturing aspects involved. It talks about EDA softwares, silicon wafers, etching, exposing, packaging and testing. Being a critical piece, Lithography gets a lot of mention. The book covers how predictions have held up till date and where we are likely heading.</p> <p>On the business side, it narrates a journey starting from enterpreneurs in Silicon Valley, to challengers in Southeast Asia, and current champions in Taiwan. It highlights the globally distributed nature of the business and the factors causing it. It covers business strategies like segregation of design and manufacturing (ARM and TSMC) as opposed to doing both (Intel). It brings the lesser known but uniquely positioned players in the industry like ASML and Texas Instruments.</p> <p>On the political arena, it brings out the critical role of governments as promoters and consumers of this technology. It highlights the initiatives of the US Department of Defense in promoting semiconductor research and the edge that it provides to US Millitary on the battlefield. It emphasizes the crucial role governments in Japan, Korea, Taiwan and recently China have played in establishing cutting edge research, design and manufacturing in their countries.</p> <p>Toward the end of the book, author focuses on the geopolitical and economic risks that arise as US lags behind countries in Southeast Asia on cutting edge manufacturing. As the biggest geopolitical rival, China is discussed in detail though it's currenlty lagging US and it's allies by at-least a few years. Author presents cases arguing how US and it's allies are better positioned to win this race in the coming decades.</p> <p>To conclude, this book is as informative as it's fascinating. To people working in related areas, it will read like a thriller novel. Owing to superb and easy presentation by the author, it will appeal to readers far beyond it's theme.</p>"},{"location":"2024/01/21/static-code-analysis-for-csharp/","title":"Static Code Analysis for CSharp","text":"<p>When it comes to static code analysis for C#, there are many options to choose from.</p> <p>This article contains my notes on C#. Information here is best to my limited knowledge and may be incomplete or incorrect. Use a definitive source as reference for your use cases. This page will be updated with new information as I find out more.</p> <p>Static code analysis is performed on the code while it is 'static', in other words 'not running'. It is in contrast to 'dynamic' or 'runtime' analysis that is done while code is executing. </p> <p>Static code analysis can surface styling, consistency, maintainability, logic and security issues among others in code.</p> <p>In contrast runtime analysis can be used to surface performance (memory, CPU, latency) issues, security issues and execution statistics.</p> <p>Static code analysis is a very important in any software project. Modern languages are so vast (especially C#), that without static code analsyis it's virtually impossible for (less-experienced) programmers to write good quality code. A nice thing is that most static analysis tools can highlight issues interactively at the time of writing code in any modern IDE like VS and VS Code.</p> <p>Furthermore these tools can be integrated into CI/CD processes, such that if any issues are surfaced, the pull request can be blocked and code anotated with issues. This ensures that rules are consistently enforced for entire codebase and all team members have to abide.</p> <p>In this article, I will give a brief about static code analysis tools available for C#.</p>"},{"location":"2024/01/21/static-code-analysis-for-csharp/#code-analysis","title":"Code Analysis","text":"<p>Code analysis is the native code analysis tool for C#. It is built-in and enabled by default for all recent .NET framework versions. However a very small set of rules are enabled in the 'Default' profile. Full ruleset is vast and covers many areas including design, maintainability, security, reliability and performance. You will have to manually configure your project to use larger - 'Recommended' profile.</p> <p>Rules surfaced by code anlaysis are shown with ID prefixed by 'CA' or 'IDE'. For instance 'CA2260'. If you are using Visual Studio and VS Code, issues are visible interactively on UI while editing/browsing code.</p> <p>Issues are surfaced as build warnings. You have option of configuring them as build errors to be strict.</p> <p>Configuration is simple, with some properties required to be set in the 'csproj' file. That way configuration gets commited into source control ensuring uniform setup across all members of the team.</p> <p>Integrating into CI pipeline can be difficult as the provided GitHub action has not been updated in years, is still in beta and only available for Windows. Another (tedious) option is to write custom script/action.</p>"},{"location":"2024/01/21/static-code-analysis-for-csharp/#stylecop-analyzers","title":"StyleCop Analyzers","text":"<p>StyleCop Analyzers as the name suggests deals with consistent styling of source code. It has a large set of opinionated style rules, for which code is scanned and violations are raised.  </p> <p>It has to be installed as a nuget package at the project level. If there are many projects in a solution, 'Directory.Build.props' file can be used to configure it for all projects in a solution. Rules can be configured via a '.ruleset' file which can be set at solution level.</p> <p>Violations are surfaced as build warnings. While coding in editor (VS/Code), issues are surfaced interactively. Wherever possible automated corrections are suggested. Integration with CI pipeline can be done by writing custom script.</p> <p>Since it is solely focused on styling, it must be used in combination with other analyzers that cover broader essential areas.</p>"},{"location":"2024/01/21/static-code-analysis-for-csharp/#sonarsource","title":"SonarSource","text":"<p>SonarSource are a set of rules that work with SonarQube - a popular multi-language code quality tool. Rules cover broad areas (security, logic, design, clean code etc.) with a lot of overlap to Code analysis rules. A major area of analysis is - 'Clean Code Attributes'. These attributes are categorized into four areas - 'Consistent', 'Intentional', 'Adaptable' and 'Responsible'. For more details on this classification refer their document.</p> <p>To configure these rules for interactive editing in IDE, use SonarLint IDE plugin. However, to gain full advantage of features, integrate it into SonarQube via CI pipeline. CI integration is very easy with ready made actions for most CI platforms. After integration, it's very easy to navigate issues using web UI provided by the product.</p> <p>SonarQube provides many code quality features apart from typical code analysis. For instance it highlights duplicate lines and offers unit-test coverage integration. It implements 'Clean as you Code' methodology which helps in reducing tech-debt over time. It has excellent documentation on all aspects of configuring and integrating it into your project.</p> <p>Downside is that, you have to pay for commercial version. While community version exists, it's difficult to integrate and use it efficiently in real life projects. </p>"},{"location":"2024/01/21/static-code-analysis-for-csharp/#codeql","title":"CodeQL","text":"<p>CodeQL is a semantic code analysis tool owned by GitHub. It supports many languages including C#. It is provided as a part of GitHub Advanced Security suite, where it's used to surface security vulnerabilities. However, you can use free command line version and run it for broader analysis which includes checks similar to SonarSource and Code analysis.</p> <p>CodeQL is a popular SAST (Static Application Security Testing) tool, typically used by security researchers. It supports a query language using which custom checks can be written. This makes it the only tool in the list which is extensible and customisable for those who want to put in that level of effort (not practical for most people).</p> <p>It can be easily integrated into CI pipeline using codeql-action provided by GitHub. The default integration checks only for security issues (can be modified to do more checks). You can do custom integration with scripts via CodeQL CLI.</p> <p>Before analysis, code needs to be built, during which a database is populated. Analysis is run over this database using queries. On large codebases the entire process can take long (hours). Output is generated to SARIF files which can be uploaded to GitHub UI for interactive viewing.</p> <p>Due to it's nature, an IDE plugin which can interactively surface issues while coding is not available.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/","title":"Checklist for new .NET C# projects","text":"<p>When starting a new .NET C# project, get these things right from the start.</p> <p>These are my notes on C#. Information here is best to my limited knowledge and may be incomplete or incorrect. Use a definitive source as reference for your use cases. This page might be updated in future.</p> <p>It's important to start things the right way. If start is not proper, you might end up with poor quality down the road, fixing which will take a lot more effort as time passes by.</p> <p>While starting a new .NET C# project on any supported (.NET 6.0 and .NET 8.0) version, you can go through these points and incorporate those that make sense for your project.</p> <p>These considerations apply to projects that have some real-world value, will last for some time and see regular contributions. For small proof of concepts and other temporary projects, these might be counter-productive.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#nuget-dependency-management","title":"NuGet Dependency Management","text":""},{"location":"2024/03/02/checklist-for-new-net-c-projects/#enable-central-package-management","title":"Enable Central Package Management","text":"<p>Once you have multiple projects in a solution with many dependencies, tracking their version and keeping them up-to-date with security fixes can be challenging. With Central Package Management, package versions are managed centrally in a 'Directory.Packages.Props' file at the solution (or repository) root. This is particularly useful for mono repos that contain many projects in a single repository. Onboarding is as simple as setting 'ManagePackageVersionsCentrally' MSBuild property to 'True'. This is fairly easy to setup even for projects that have significant past contributions. If you want to override package version for a specific project, it's possible by using hierarchy of version files. After enabling this feature, you use NuGet as you usually do and Visual Studio (or dotnet CLI) will take care of updating correct files.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#enable-repeatable-package-restore","title":"Enable Repeatable Package Restore","text":"<p>There are a bunch of nitty-gritties in NuGet package restore process, which can lead to dependencies for same commit being restored differently at different times. These are well explained in the Repeatable Package Restore feature blog. By enabling this feature restore process involves a 'packages.lock.json' file that contains exact version of dependencies (and recursive sub-dependencies) with their cryptographic hashes. When restoring, operation fails if exact match is not resolved. Enabling this also provides you protection against some supply chain attacks that target NuGet ecosystem. Enabling this feature in a project with significant past contributions is easy.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#enabling-central-package-feed-with-upstream-source-integration","title":"Enabling Central Package Feed With Upstream Source Integration","text":"<p>If you project needs to restore NuGet packages from multiple sources, possibly including both private (internal to your organization) and public sources, then you can consider usingS a central private source with integration to upstream sources. It's very easy to setup in Azure DevOps using Azure Artifacts Upstream Sources feature. Benefits include a simplified NuGet setup in your project, protection against supply chain attacks and some other benefits. By ordering upstream sources properly, you can protect against package substitution supply chain attacks.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#code-quality","title":"Code Quality","text":""},{"location":"2024/03/02/checklist-for-new-net-c-projects/#configure-code-analysis","title":"Configure Code Analysis","text":"<p>Code analysis is the native code analysis tool for C#. It is built-in and enabled by default for all recent .NET framework versions. However a very small set of rules are enabled in the 'Default' profile. Full ruleset is vast and covers many areas including design, maintainability, security, reliability and performance. You will have to manually configure your project to use larger - 'Recommended' profile. Enabling recommended profile will make sure that some common quality issues are surfaced as warnings at build time which should be fixed to keep code in a good shape. It's strongly recommended to enable this while starting a new project, otherwise acummulated debt over time can make it difficult to enable and fix all issues at a later stage. </p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#install-stylecop-analyzers","title":"Install StyleCop Analyzers","text":"<p>StyleCop Analyzers as the name suggests deals with consistent styling of source code. It has a large set of opinionated style rules, for which code is scanned and build warnings are raised. This ensures that your codebase looks like a team-work rather than a patch-work involving multiple people who follow their own styles. Enabling this from start is recommended to prevent acummulated tech debt over time. A tool like this is especially required for C# as it allows for very flexible styling.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#devops","title":"DevOps","text":""},{"location":"2024/03/02/checklist-for-new-net-c-projects/#release-versioning-using-nerdbankgitversioning","title":"Release Versioning Using Nerdbank.GitVersioning","text":"<p>There can be multiple strategies for release versioning depending on the project requirements. Nerdbank.GitVersioning is an attempt to tackle this age old problem using a new approach. It maintains Semantic Versioning of project releases by comitting the version data to a 'version.json' file directly in the project Git repository. This is opposed to using Git Tags that are not very stable and often manually created, although you can also create tags using this tool. At the time of building the project in pipeline, it can tag generated DLLs with release version, which can then be referenced and consumed from inside the code.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#setup-quality-gate-workflow","title":"Setup Quality Gate Workflow","text":"<p>Setting up a quality gate workflow early on can prevent technical debt from acummulating. You can run all sorts of quality, security and compliance check in this workflow whenever a new contribution is pushed to your repository. One common strategy is to let contributions only via Pull Requests (PR) and run quality gate workflow everytime a PR is created or updated. Merging of PR can be blocked until all issues reported by workflow are fixed.</p>"},{"location":"2024/03/02/checklist-for-new-net-c-projects/#security","title":"Security","text":""},{"location":"2024/03/02/checklist-for-new-net-c-projects/#codeql","title":"CodeQL","text":"<p>CodeQL is a static analysis (SAST) tool that is typically used to surface security issues in code. It has easy and well-documented integration with GitHub repositories. For compiled languages like C#, the setup is a bit more complex as it involves buliding the code. It makes sense to have CodeQL as a part of Quality Gate workflow in your repository. Issues surfaced are annotated in the pull request and also visible directly in GitHub repository security tab. It's free for public repositories and can be licensed for commercial uses.</p>"},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/c-notes/","title":"C# Notes","text":""},{"location":"category/book-review/","title":"Book Review","text":""}]}